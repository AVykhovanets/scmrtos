//********************************************************************************
//*
//*     FULLNAME:  Single-Chip Microcontroller Real-Time Operating System
//*
//*     NICKNAME:  scmRTOS
//*
//*     PROCESSOR: LPC2xxx (NXP)
//*
//*     TOOLKIT:   EWARM (IAR Systems)
//*
//*     PURPOSE:   C-Spy debugger setup macros
//*
//*     Version:   3.00-beta
//*
//*     $Revision$
//*     $Date$
//*
//*     Copyright (c) 2003-2007, Harry E. Zhurov
//*
//*     Permission is hereby granted, free of charge, to any person
//*     obtaining  a copy of this software and associated documentation
//*     files (the "Software"), to deal in the Software without restriction,
//*     including without limitation the rights to use, copy, modify, merge,
//*     publish, distribute, sublicense, and/or sell copies of the Software,
//*     and to permit persons to whom the Software is furnished to do so,
//*     subject to the following conditions:
//*
//*     The above copyright notice and this permission notice shall be included
//*     in all copies or substantial portions of the Software.
//*
//*     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//*     EXPRESS  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
//*     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
//*     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
//*     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
//*     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
//*     THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//*
//*     =================================================================
//*     See http://scmrtos.sourceforge.net for documentation, latest
//*     information, license and contact details.
//*     =================================================================
//*
//******************************************************************************
//*     ARM port by Sergey A. Borshch, Copyright (c) 2006-2007

execUserReset()
{
    Reset();
    Remap_RAM();
}

execUserPreload()
{
    Reset();
    Remap_RAM();
}

Remap_RAM()
{
    __var i;
    __var tmp;

    if( __driverType("sim"))                            // simulate remapping, copy INTVEC from RAM to 0x00000000
    {
        for( i = 0; i < 0x40; i += 4 )
        {
            tmp = __readMemory32(0x40000000 + i, "Memory");
            __writeMemory32(tmp,0x00000000 + i, "Memory");
        }
    }

    // remap throw JTAG
    writeMasked8(0x02,0xE01FC040,0x03);	                // MEMMAP, remap vectors to RAM
    __message " remap done ";

}

Reset()
{
    writeMasked32(0x00000000,0xE01FC0C0,0x00000003);    // PCON, disable power-down
    writeMasked32(0x000017BE,0xE01FC0C4,0x000017BE);    // PCONP, all periph. enabled

    __writeMemory32(0x00000000,0xE0028008,"Memory");    // I0DIR
    __writeMemory32(0xFFFFFFFF,0xE002800C,"Memory");    // I0CLR
    __writeMemory32(0x00000000,0xE0028018,"Memory");    // I1DIR
    __writeMemory32(0xFFFFFFFF,0xE002801C,"Memory");    // I1CLR
    __writeMemory32(0x00000000,0xE0028028,"Memory");    // I2DIR
    __writeMemory32(0xFFFFFFFF,0xE002802C,"Memory");    // I2CLR
    __writeMemory32(0x00000000,0xE0028038,"Memory");    // I3DIR
    __writeMemory32(0xFFFFFFFF,0xE002803C,"Memory");    // I3CLR

    __writeMemory32(0x00000000,0xE002C000,"Memory");    // PINSEL0
    __writeMemory32(0x15400000,0xE002C004,"Memory");    // PINSEL1
    writeMasked32(0x006100F0,0xE002C014,0x0FF3E9F0);    // PINSEL2

    writeMasked8(0x00,0xE01FC100,0x33);                 // VPBDIV, pclk/4

    __writeMemory32(0xFFFFFFFF,0xFFFFF014,"Memory");    // VICIntEnClr, disable ints

    writeMasked8(0x00,0xE01FC148,0x0F);                 // EXTMODE
    writeMasked8(0x00,0xE01FC144,0x0F);                 // EXTWAKE
    writeMasked8(0x00,0xE01FC14C,0x0F);                 // EXTPOLAR
    writeMasked8(0x0F,0xE01FC140,0x0F);                 // EXTINT, reset flags
/*
    // SPI0
    __readMemory8(0xE0020004,"Memory");                 // SPSR clear status & int flags
    // SPI1
    __readMemory8(0xE0030004,"Memory");                 // SPSR clear status & int flags
    // UART0
    __readMemory8(0xE000C008,"Memory");                 // U0IIR
    __readMemory8(0xE000C014,"Memory");	                // U0LSR
    // UART1
    __readMemory8(0xE0001008,"Memory");                 // U1IIR
    __readMemory8(0xE0001014,"Memory");                 // U1LSR
    __readMemory8(0xE0001018,"Memory");                 // U1MSR
    // I2C
    __writeMemory8(0x6C, 0xE001C018,"Memory");          // I2C CONCLR
    __readMemory8(0xE001C004,"Memory");                 // I2C STAT
    // Timers
    __writeMemory8(0x00, 0xE0004004,"Memory");          // Timer0 TCR disable timer
    __writeMemory8(0xFF, 0xE0004000,"Memory");          // Timer0 IR clear pending int flags
    __writeMemory8(0x00, 0xE0008004,"Memory");          // Timer1 TCR disable timer
    __writeMemory8(0xFF, 0xE0008000,"Memory");          // Timer1 IR clear pending int flags
    // PWM
    __writeMemory32(0x00000000, 0xE0014004,"Memory");   // PWMTCR, disable timer
    __writeMemory32(0x00000000, 0xE0014008,"Memory");   // PWMTR, clear timer
    __writeMemory32(0x0000070F, 0xE0014000,"Memory");   // PWMIR clear pending int flags

    // Reset VIC
    __writeMemory32(0xFFFFFFFF,0xFFFFF01C,"Memory");    // VICSoftIntClr, clear sof int flags
    __writeMemory32(0x00000000,0xFFFFF00C,"Memory");    // VICIntSelect, all ints are IRQ
    __writeMemory32(0x00000000,0xFFFFF020,"Memory");    // VICProtection, disable protection

    __writeMemory32(0x00000000,0xFFFFF034,"Memory");    // VICDefVectAddr

    for( i = 0; i < 16; i++ )
    {
        __writeMemory32(0x00000000,0xFFFFF100 + i * 4,"Memory");    // VICVecAdr_x
        __writeMemory32(0x00000000,0xFFFFF200 + i * 4,"Memory");    // VICVecCntl_x
    }

    __writeMemory32(0x00000000,0xFFFFF030,"Memory");    // VICVecAddr, reset controller
*/

    if( __driverType("sim"))
    {
        __writeMemory16(0x0400, 0xE01FC088, "Memory");  // PLLSTAT, emulate PLL lock
    }

    __writeMemory32(0xD3, 0x98, "Register");            // CPSR = SVC mode, ARM, IRQ, FIQ disabled
    __writeMemory32(0x00000000, 0xB4 ,"Register");      // SET PC
}

writeMasked8(value, location, mask) {                   // mask: 1's on bits allowed to overwrite
    __var NewValue;
    NewValue = __readMemory8(location,"Memory");
    NewValue = NewValue & ~mask;                        // clear unmasked bits
    value = value & mask;                               // clear masked bits
    NewValue = NewValue | value;                        // set desired bits
    __writeMemory8(NewValue, location,"Memory");
}

writeMasked32(value, location, mask) {                  // mask: 1's on bits allowed to overwrite
    __var NewValue;
    NewValue = __readMemory32(location,"Memory");
    NewValue = NewValue & ~mask;                        // clear unmasked bits
    value = value & mask;                               // clear masked bits
    NewValue = NewValue | value;                        // set desired bits
    __writeMemory32(NewValue, location,"Memory");
}
