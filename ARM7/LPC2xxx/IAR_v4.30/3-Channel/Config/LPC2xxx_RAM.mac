//*****************************************************************
//  Macro file for IAR C-SPY debugger
//
//  Performs some necessary actions for debugging with C-SPY
//  
//
//  Copyright (c) 2007-2008, Sergey A. Borshch
//
//  $Revision$
//  $Date::             $
//
//*****************************************************************

execUserReset()
{
    Reset();
    Remap_RAM();
}

execUserPreload()
{
    Reset();
    Remap_RAM();
}

Remap_RAM()
{
    __var i;
    __var tmp;

    if( __driverType("sim"))                            // simulate remapping, copy INTVEC from RAM to 0x00000000
    {
        for( i = 0; i < 0x40; i += 4 )
        {
            tmp = __readMemory32(0x40000000 + i, "Memory");
            __writeMemory32(tmp,0x00000000 + i, "Memory");
        }
    }

    // remap throw JTAG
    writeMasked8(0x02,0xE01FC040,0x03);                 // MEMMAP, remap vectors to RAM
    __message " remap done ";

}

Reset()
{
    __var i;
    writeMasked32(0x00000000,0xE01FC0C0,0x00000003);    // PCON, disable power-down
    writeMasked32(0x000017BE,0xE01FC0C4,0x000017BE);    // PCONP, all periph. enabled

    __writeMemory32(0x00000000,0xE0028008,"Memory");    // I0DIR
    __writeMemory32(0xFFFFFFFF,0xE002800C,"Memory");    // I0CLR
    __writeMemory32(0x00000000,0xE0028018,"Memory");    // I1DIR
    __writeMemory32(0xFFFFFFFF,0xE002801C,"Memory");    // I1CLR
    __writeMemory32(0x00000000,0xE0028028,"Memory");    // I2DIR
    __writeMemory32(0xFFFFFFFF,0xE002802C,"Memory");    // I2CLR
    __writeMemory32(0x00000000,0xE0028038,"Memory");    // I3DIR
    __writeMemory32(0xFFFFFFFF,0xE002803C,"Memory");    // I3CLR

    __writeMemory32(0x00000000,0xE002C000,"Memory");    // PINSEL0
    __writeMemory32(0x15400000,0xE002C004,"Memory");    // PINSEL1
    writeMasked32(0x006100F0,0xE002C014,0x0FF3E9F0);    // PINSEL2

    writeMasked8(0x00,0xE01FC100,0x33);                 // VPBDIV, pclk/4

    __writeMemory32(0xFFFFFFFF,0xFFFFF014,"Memory");    // VICIntEnClr, disable ints

    writeMasked8(0x00,0xE01FC148,0x0F);                 // EXTMODE
    writeMasked8(0x00,0xE01FC144,0x0F);                 // EXTWAKE
    writeMasked8(0x00,0xE01FC14C,0x0F);                 // EXTPOLAR
    writeMasked8(0x0F,0xE01FC140,0x0F);                 // EXTINT, reset flags
/*
    // SPI0
    __readMemory8(0xE0020004,"Memory");                 // SPSR clear status & int flags
    // SPI1
    __readMemory8(0xE0030004,"Memory");                 // SPSR clear status & int flags
    // UART0
    __readMemory8(0xE000C008,"Memory");                 // U0IIR
    __readMemory8(0xE000C014,"Memory");                 // U0LSR
    // UART1
    __readMemory8(0xE0001008,"Memory");                 // U1IIR
    __readMemory8(0xE0001014,"Memory");                 // U1LSR
    __readMemory8(0xE0001018,"Memory");                 // U1MSR
    // I2C
    __writeMemory8(0x6C, 0xE001C018,"Memory");          // I2C CONCLR
    __readMemory8(0xE001C004,"Memory");                 // I2C STAT
    // Timers
    __writeMemory8(0x03, 0xE0004004,"Memory");          // Timer0 TCR enable and reset timer
    __writeMemory8(0xFF, 0xE0004000,"Memory");          // Timer0 IR clear pending int flags
    __writeMemory8(0x00, 0xE0004004,"Memory");          // Timer0 TCR disable timer
    __writeMemory8(0x03, 0xE0008004,"Memory");          // Timer1 TCR enable and reset timer
    __writeMemory8(0xFF, 0xE0008000,"Memory");          // Timer1 IR clear pending int flags
    __writeMemory8(0x00, 0xE0008004,"Memory");          // Timer1 TCR disable timer
    // PWM
    __writeMemory32(0x00000000, 0xE0014004,"Memory");   // PWMTCR, disable timer
    __writeMemory32(0x00000000, 0xE0014008,"Memory");   // PWMTR, clear timer
    __writeMemory32(0x0000070F, 0xE0014000,"Memory");   // PWMIR clear pending int flags
*/
    // Reset VIC
    __writeMemory32(0xFFFFFFFF,0xFFFFF01C,"Memory");    // VICSoftIntClr, clear soft int's flags
    __writeMemory32(0x00000000,0xFFFFF00C,"Memory");    // VICIntSelect, all ints are IRQ
    __writeMemory32(0x00000000,0xFFFFF020,"Memory");    // VICProtection, disable protection

    __writeMemory32(0x00000000,0xFFFFF034,"Memory");    // VICDefVectAddr

    for( i = 0; i < 16; i++ )
    {
        __writeMemory32(0x00000000,0xFFFFF100 + i * 4,"Memory");    // VICVecAdr_x
        __writeMemory32(0x00000000,0xFFFFF200 + i * 4,"Memory");    // VICVecCntl_x
    }

    __writeMemory32(0x00000000,0xFFFFF030,"Memory");    // VICVecAddr, reset controller


    if( __driverType("sim"))
    {
        __writeMemory16(0x0400, 0xE01FC088, "Memory");  // PLLSTAT, emulate PLL lock
    }

    __writeMemory32(0xD3, 0x98, "Register");            // CPSR = SVC mode, ARM, IRQ, FIQ disabled
    __writeMemory32(0x00000000, 0xB4 ,"Register");      // SET PC
}

writeMasked8(value, location, mask) {                   // mask: 1's on bits allowed to overwrite
    __var NewValue;
    NewValue = __readMemory8(location,"Memory");
    NewValue = NewValue & ~mask;                        // clear unmasked bits
    value = value & mask;                               // clear masked bits
    NewValue = NewValue | value;                        // set desired bits
    __writeMemory8(NewValue, location,"Memory");
}

writeMasked32(value, location, mask) {                  // mask: 1's on bits allowed to overwrite
    __var NewValue;
    NewValue = __readMemory32(location,"Memory");
    NewValue = NewValue & ~mask;                        // clear unmasked bits
    value = value & mask;                               // clear masked bits
    NewValue = NewValue | value;                        // set desired bits
    __writeMemory32(NewValue, location,"Memory");
}
